## 1、垃圾回收机制

### 1.1、引用计数法

在被引用的时候 计数器加一，当计数器减少为0时，说明没有被人引用了，立刻清理释放内存。

![](images/image-20220807152347836.png)

### 1.2、可达性分析

**从一个被称为GC Roots的对象开始向下搜索**，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可达的，不可用。要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。

**作为GC Roots的对象有以下几种：**

1. 虚拟机栈中引用的对象
2. 方法区类静态属性引用的对象
3. 方法区常量池引用的对象
4. 本地方法栈JNI引用的对象

![](images/image-20220807152501765.png)
可以理解为标记清除（这个思想后面会说），存在的弊端是，当内存不足的时候，再扫描，原本不富裕的家庭更加艰辛了，这样扫描的时间也会长一点。这种就是攒着，一次性处理。而不论标记清除还是计数。

而不论是标记清楚或者是引用计数，都只关心引用类型，不管数据类型，所以JVM还需要判断栈上的数据是什么类型的，这里又分为了 保守GC、半保守GC、准确式GC


|GC 类型|特点|优点|缺点|
|---|---|---|---|
|**保守GC**|宽松地处理内存指针，容易误判内存回收|实现简单，适用范围广|可能导致内存泄漏，效率较低|
|**半保守GC**|比保守GC更精确，但仍有一定误判|提供一定的准确性和性能平衡|仍可能存在少量误回收问题|
|**准确式GC**|精确追踪对象指针，确保准确回收无用对象|高度准确，避免内存泄漏|实现复杂，性能开销大|

## 2、垃圾回收算法

### 2.1、分代收集算法 (Java对象头)

堆分为新生代、老年代，其中新生代的对象有着朝生夕死的特性，因此GC特别频繁，需要追溯标记的对象也很少，都是直接干掉。如果用 **标记-清除** 的话，需要对对象处理很多次。因此可以使用**标记-复制**算法，每次将存活的对象复制到另一个区域，剩下的直接干掉就行了。但是朴素的 **标记-复制**算法将堆对半分，这样效率很低，只有50%，所以 虚拟机分为了 Eden 区和 两个 survivor，默认比例死 8:1:1 这样能有 90% 的利用率。每次回收将存活对象拷贝到 survivor区就可以了， 这就是 分配担保机制

![](images/image-20220806123310726.png)

老年代的对象基本上都不是垃圾，追溯标记非常耗时，回收率也比较低，所以安排的少一点，这样一来，新生代回收多、老年代回收少，这样就区分出来了分代收集的特性。（下面讲 标记-清除、复制)


> 这里要强调一点，如果 GC 一次，没有被回收的对象 `分代年龄` 会`+1` ，每一次回收会在 `s0` 、 `s1` 区间挪来挪去，直到分代年龄到 `15` 岁，就会被挪到 `老年代`
> 
> 那这个分代年龄存放在哪里呢？是存在在`对象头`中的


![](images/image-20220806125040986.png)

### 2.2、标记-清除

分为两个阶段，标记阶段、清除阶段

**标记阶段**：全局遍历从根（栈、寄存器、全局变量） 开始遍历，凡是垃圾，统统标记

**清除阶段**：然后把标记住的，统统干掉，这里删一点，那里删一点，这样就会存在很多碎片化的空间

> 清除不会移动和整理内存空间

![](images/image-20220807154246280.png)
这就使得明明总的内存是足够的，但就是申请不到内存，在申请的时候，也需要遍历链表去查合适的内存块。比较耗时。所以就会有 **多个链表的实现**

![](images/image-20220807154325688.png)

当然还可以分更多，这里只画了 2 个

还有标记，标记的话一般我们会觉得应该是标记在对象身上，比如标记位放在对象头中，等于每一次 GC 都需要修改对象，因此就有一种**位图标记法**，其实就是将堆的内存某个块用一个位来标记。就像我们的内存是一页一页的，堆中的内存可以分成一块一块，而对象就是在一块，或者多块内存上

这样，就不用去扫描整个堆而去清除对象了。

但是不论是标记对象头还是利用位图，**标记-清除**的碎片问题还是处理不了。

因此就引出了标记-复制和标记-整理。

### 2.3、标记-复制

首先这个算法会把堆分为两块，一块是 From、一块是 To。

对象只会在 From 上生成，发生 GC 之后会找到所有存活对象，然后将其复制到 To 区，之后整体回收 From 区。

再将 To 区和 From 区身份对调，即 To 变成 From ， From 变成 To，我再用图来解释一波。

![](images/image-20220807155754558.png)

可以看到内存的分配是紧凑的，不会有内存碎片的产生。

不需要空闲链表的存在，直接移动指针分配内存，效率很高。

简单粗暴的把活动的内存，一箩筐移到另一个区中，相当紧密，缺点是，效率是50%，因需要对半分内存空间。如果存活的对象非常多的话，也会很困难，要挪很多，所以不适用保守型的GC

### 2.4、标记-整理

和标记-复制差不多，区别在于复制算法是分为两个区来回复制，而且整理不分区，直接整理。这种就是不挪到另一个分区了，直接整理到一块，删掉垃圾。

![](images/image-20220807155944476.png)

至此相信你对标记-清除、标记-复制和标记-整理都清晰了，让我们再回到刚才提到的分代收集

### 2.5、跨代引用

有了分代收集到基础，提高了垃圾收集的效率，但是新生代在回收的时候，有可能被老年代引用，老年代也作为根，那这样扫描整个老年代，效率又低了。

此时：记忆集（Remembered Set） 出现了，他可以记录跨代之间的引用而避免扫描整体非收集区域，因此记忆集就是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。根据记录的精度分为

- 字长精度，每条记录精确到机器字长
- 对象精度，每条记录精确到对象
- 卡精度，每条记录精确到一块内存区域

最常见的是卡精度来实现记忆集，称之为卡表。

什么叫卡呢？

拿对象精度来距离，假设新生代对象 A 被老年代对象 D 引用了，那么就需要记录老年代 D 所在的地址引用了新生代对象。

那卡的意思就是将内存空间分成很多卡片。假设新生代对象 A 被老年代 D 引用了，那么就需要记录老年代 D 所在的那一块内存片有引用新生代对象。

## 3、总结垃圾回收

1. 关于垃圾回收首先是找到垃圾，而找出垃圾分为两个流派，一个是引用计数、一个是可达性分析
2. 引用计数垃圾回收的及时，对内存比较友好，但是循环引用无法处理
3. 可达性分析基本上是现代垃圾回收核心选择，因为需要统一回收比较耗时，容易影响应用正常运行，所以可达性分析的研究方向就是如何减少程序运行的影响，即减少 STW 的时间
4. 因此根据对象分代假说研究分代收集，根据对象的特征划分了新生代和老年代，采取不同的收集算法，提升了回收效率。
5. 想法设法拆解GC的步骤使得可以与应用线程开发，并采取并行收集，加快收集速度。

Python 的垃圾回收（便携式垃圾收集器）https://arctrix.com/nas/python/gc
OpenJDK HotSpot 术语表：https://openjdk.org/groups/hotspot/docs/HotSpotGlossary.html
RednaxelFX ，技术博主收集对VM目录：https://www.iteye.com/blog/user/rednaxelafx
简书，美团JAVA，综合性技术博主：https://www.jianshu.com/u/90ab66c248e6