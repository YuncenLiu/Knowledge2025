---
createTime: 2022-08-02
---
[toc]
## 1、JVM调优的目的是什么？

程序在运行过程中，会有不断的数据往老年代里放，如果老年代放满了，Java虚拟机并不是立即抛出 `OOM`，而是先进行一次 `FullGC`，当 `FullGC` 之后如果还没有足够的空间，此时才会抛出 `OOM` 异常。
那我们清楚了有这样一个 `FullGC` 的过程后，再返回这个问题，`Java` 虚拟机调优的目的就是为了让程序减少 `FullGC` 的次数。why？
因为程序在 `gc` 时候，无论是 `minor gc` 还是 `full gc`，都会进行 `STW`

## 2、什么是 STW

当程序在 `gc` 时，`java` 虚拟机会停掉所有的线程，专心的去收集垃圾去清理垃圾。如果这个时候，用户去使用一个功能，就会存在一定的卡顿。这个卡顿是间歇性的，可能一会以后就会好。但是经常性的卡顿，那就不行了。这个卡顿的过程，我们就称为是 `STW`（stop the world）

因此我们要规避 `stw` 过程，让程序流畅

## 3、设计JVM的时候，为什么要设置 STW 呢？不设置不行吗？

如果不设计 `STW`，也就是在 `GC` 的时候，程序线程一直在运行，有可能这个对象刚还不是垃圾，但线程运行完之后就变为垃圾了，或者原本是垃圾的对象，又被引用，又不是垃圾了。这就让 `GC` 很头痛了，他需要重新又去遍历整个堆，这还不算上堆中对象的变化。于此如此，`JVM` 不如暂停所有线程，等他执行完`GC`后，`STW`结束后再继续线程任务！

## 4、模拟真实案例，大批量数据处理

假设，一个大型活动，每秒 1000 单实时数据处理，部署 3 台 4C8G 服务器，每秒处理 300 个订单。根据对象大小和成员变量， int 类型占 4字节计算，一个订单不超过 1Kb，每秒 300K 订单生成。
处理过程中涉及其他对象，库存、优惠券等，放大20倍，除此之外还有其他查询操作，再放大 10 倍。
估算 60M/s 对象生成，生成后 1s 就变成垃圾，服务器配置 4C8G，所以 JVM 参数是

```sh
java -Xms3G -Xmx3G -Xss1M -XX:MetaspaceSize=512M -XX:MaxMetaspaceSize=512M -jar order-server.jar
```

![](images/image-20220820083924395.png)

 -Xms 3G、-Xmx 3G，最大最小 3G，老年代占 3/2 堆，Eden占 1 G，s 比例 8:1:1 所以 S0、S1 分别都是 100M
现在以每秒 60M 往 Eden 写，大概十几秒就占满了 800M 的 Eden，触发一次 minor
程序触发 minor gc，使得 STW，线程挂起。

有一批对象从 `eden` 区挪到 `survivor` 区，如果这批对象超过 `survivor` 区的 50%，**就直接进入老年代**
可以通过 `-XX:TargetSurvivorRatio` 指定这一比例，很显然，60M 超过了 S区（100M）的50%，直接进入老年代，每隔 十几秒就会有 60M 数据直接进入老年代，2G 老年代，五六分钟就放满了，此时触发 full GC，说白了都已经是垃圾了，还要存进老年代触发 FullGC，很显然不合理。

### 4.1、调优过程

上述场景，对JVM进行调优，让其几乎不发生 Full GC，不能说完全不发生，几周甚至几个月不发生一次

```
java -Xms3G -Xmx3G -Xmn2G -Xss1M -XX:MetaspaceSize=512M -XX:MaxMetaspaceSize=512M -jar order-server.jar
```
![](images/image-20220820091338718.png)

+ `-Xmn2G` 年轻代 2个G，其他不变
当然，我们也可以直接指定 `survivor` 区大小，这里还是按默认 8:1:1 来

当 `survivor` 区有200M以后，我们刚刚说的那一批从 eden区挪过来的未执行完订单的对象，就不会往老年代中存放，就安心的放在 `survivor` ，等下一次再触发 `minor gc` 时，就会把新生代包括 `survivor` 这一块垃圾给回收掉。所以只会有少数老顽固的对象才会被挪到老年代。

像这样朝生夕死的对象都会在新生代就被干掉，再也不会挪到老年代！也就不会频繁的触发`full gc`，不会频繁 `stw`，不会频繁挂起 `java` 线程，不会频繁影响用户操作，从而达到调优目的